// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: cowboy.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCowboy = `-- name: CreateCowboy :one
INSERT INTO cowboys (name, health, damage) VALUES ($1, $2, $3) RETURNING id::uuid
`

type CreateCowboyParams struct {
	Name   string `json:"name"`
	Health int32  `json:"health"`
	Damage int32  `json:"damage"`
}

func (q *Queries) CreateCowboy(ctx context.Context, arg CreateCowboyParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCowboy, arg.Name, arg.Health, arg.Damage)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

type CreateManyCowboysParams struct {
	Name   string `json:"name"`
	Health int32  `json:"health"`
	Damage int32  `json:"damage"`
}

const deleteAllCowboys = `-- name: DeleteAllCowboys :exec
DELETE from cowboys
`

func (q *Queries) DeleteAllCowboys(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllCowboys)
	return err
}

const getRandomCowboy = `-- name: GetRandomCowboy :one
SELECT id, created_at, updated_at, deleted_at, name, health, damage from cowboys
Where health > 0 AND id != $1
order by random()
LIMIT 1
`

func (q *Queries) GetRandomCowboy(ctx context.Context, id uuid.UUID) (*Cowboy, error) {
	row := q.db.QueryRow(ctx, getRandomCowboy, id)
	var i Cowboy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Health,
		&i.Damage,
	)
	return &i, err
}

const getSingleAliveCowboyAndCount = `-- name: GetSingleAliveCowboyAndCount :one
SELECT a.id, a.created_at, a.name, a.health, a.damage,
       (
           Select count(*) from cowboys as b where health > 0 AND deleted_at IS NULL AND b.id != $1
       ) AS available
from cowboys as a where a.id = $1 AND health > 0
`

type GetSingleAliveCowboyAndCountRow struct {
	ID        uuid.UUID          `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Name      string             `json:"name"`
	Health    int32              `json:"health"`
	Damage    int32              `json:"damage"`
	Available int64              `json:"available"`
}

func (q *Queries) GetSingleAliveCowboyAndCount(ctx context.Context, id uuid.UUID) (*GetSingleAliveCowboyAndCountRow, error) {
	row := q.db.QueryRow(ctx, getSingleAliveCowboyAndCount, id)
	var i GetSingleAliveCowboyAndCountRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Health,
		&i.Damage,
		&i.Available,
	)
	return &i, err
}

const getSingleAliveCowboyById = `-- name: GetSingleAliveCowboyById :one
SELECT id, created_at, updated_at, deleted_at, name, health, damage from cowboys where id = $1 AND health > 0
`

func (q *Queries) GetSingleAliveCowboyById(ctx context.Context, id uuid.UUID) (*Cowboy, error) {
	row := q.db.QueryRow(ctx, getSingleAliveCowboyById, id)
	var i Cowboy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Health,
		&i.Damage,
	)
	return &i, err
}

const getSingleCowboyByName = `-- name: GetSingleCowboyByName :one
SELECT id, created_at, updated_at, deleted_at, name, health, damage from cowboys where name = $1 limit 1
`

func (q *Queries) GetSingleCowboyByName(ctx context.Context, name string) (*Cowboy, error) {
	row := q.db.QueryRow(ctx, getSingleCowboyByName, name)
	var i Cowboy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Health,
		&i.Damage,
	)
	return &i, err
}

const getSingleCowboyHealth = `-- name: GetSingleCowboyHealth :one
SELECT health from cowboys where id = $1
`

func (q *Queries) GetSingleCowboyHealth(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getSingleCowboyHealth, id)
	var health int32
	err := row.Scan(&health)
	return health, err
}

const listAliveCowboys = `-- name: ListAliveCowboys :many
SELECT id, created_at, updated_at, deleted_at, name, health, damage FROM cowboys WHERE health > 0 AND
    deleted_at IS NULL
ORDER BY
    CASE WHEN $1::text = 'desc' THEN created_at END DESC,
    CASE WHEN $1::text = 'asc' THEN created_at END ASC
LIMIT $3::int
    OFFSET $2::int
`

type ListAliveCowboysParams struct {
	QuerySort   string `json:"query_sort"`
	QueryOffset int32  `json:"query_offset"`
	QueryLimit  int32  `json:"query_limit"`
}

func (q *Queries) ListAliveCowboys(ctx context.Context, arg ListAliveCowboysParams) ([]*Cowboy, error) {
	rows, err := q.db.Query(ctx, listAliveCowboys, arg.QuerySort, arg.QueryOffset, arg.QueryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Cowboy
	for rows.Next() {
		var i Cowboy
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Health,
			&i.Damage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reduceCowboyHealth = `-- name: ReduceCowboyHealth :exec
UPDATE cowboys SET health = (health - $1),
updated_at = NOW() WHERE id = $2::uuid
`

type ReduceCowboyHealthParams struct {
	ShooterDamage int32     `json:"shooter_damage"`
	VictimID      uuid.UUID `json:"victim_id"`
}

func (q *Queries) ReduceCowboyHealth(ctx context.Context, arg ReduceCowboyHealthParams) error {
	_, err := q.db.Exec(ctx, reduceCowboyHealth, arg.ShooterDamage, arg.VictimID)
	return err
}

const updateCowboyHealth = `-- name: UpdateCowboyHealth :one
UPDATE cowboys SET health = (health + $1),
    updated_at = NOW() WHERE id = $2::uuid RETURNING id, created_at, updated_at, deleted_at, name, health, damage
`

type UpdateCowboyHealthParams struct {
	Health int32     `json:"health"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateCowboyHealth(ctx context.Context, arg UpdateCowboyHealthParams) (*Cowboy, error) {
	row := q.db.QueryRow(ctx, updateCowboyHealth, arg.Health, arg.ID)
	var i Cowboy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Health,
		&i.Damage,
	)
	return &i, err
}
